import { useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useWebSocket } from './useWebSocket';
import {
  setConnected,
  setRooms,
  setRoomsLoading,
  updateRoomPlayers,
  updatePlayerReady,
  updateRoomInfo,
  setRoomLoading,
  setError,
  resetRoom,
  type Room,
  type WaitingPlayer,
  type Quizz
} from '../store/websocketSlice';
import type { RootState } from '../store/types';

interface UseWebSocketStoreProps {
  roomId?: string | null;
  onRoomCreated?: (roomId: number) => void;
}

export const useWebSocketStore = ({ roomId, onRoomCreated }: UseWebSocketStoreProps = {}) => {
  const dispatch = useDispatch();
  
  // S√©lecteurs Redux
  const {
    isConnected,
    hasReceivedData,
    rooms,
    roomsLoading,
    currentRoom,
    roomLoading,
    error
  } = useSelector((state: RootState) => state.websocket);

  // Gestionnaire de messages centralis√©
  const handleMessage = useCallback((data: unknown) => {
    console.log('Message WebSocket re√ßu:', data);
    console.log('üîç Type de data:', typeof data);
    console.log('üîç Est-ce un objet?', typeof data === 'object');
    console.log('üîç Cl√©s de data:', data && typeof data === 'object' ? Object.keys(data as object) : 'N/A');

    // G√©rer les messages avec format user/message (format du serveur)
    if (data && typeof data === 'object' && 'user' in data && 'message' in data) {
      console.log('‚úÖ Message reconnu comme format user/message');
      const userMessage = data as { user: string; message: string };
      console.log('Message utilisateur re√ßu:', userMessage);
      
      // Traitement simplifi√© pour diagnostiquer
      try {
        // Essayer de parser le message JSON
        let parsedMessage: unknown = null;
        
        if (typeof userMessage.message === 'string') {
          // Essayer de parser directement
          try {
            parsedMessage = JSON.parse(userMessage.message);
            console.log('‚úÖ Message pars√©:', parsedMessage);
          } catch {
            // Si √ßa √©choue, utiliser le message tel quel
            parsedMessage = userMessage.message;
            console.log('‚úÖ Message utilis√© tel quel:', parsedMessage);
          }
        } else {
          parsedMessage = userMessage.message;
        }
        
        // Traiter le message pars√©
        if (parsedMessage && typeof parsedMessage === 'object' && 'type' in parsedMessage) {
          const messageData = parsedMessage as { type: string; [key: string]: unknown };
          
          switch (messageData.type) {
            case 'salons_init':
              if ('salons' in messageData) {
                console.log('Donn√©es des salons re√ßues:', messageData.salons);
                dispatch(setRooms(messageData.salons as Room[]));
              }
              break;
              
            case 'join_room':
              console.log('Confirmation de rejoindre la salle');
              dispatch(setRoomLoading(false));
              break;
              
            case 'get_room_info':
            case 'get_room_players':
              console.log('Confirmation de demande de donn√©es:', messageData.type);
              break;
              
            case 'room_info':
              if ('quizz' in messageData && 'isQuickPlay' in messageData) {
                console.log('Informations de salle re√ßues:', messageData.quizz);
                dispatch(updateRoomInfo({
                  quizz: messageData.quizz as Quizz,
                  isQuickPlay: messageData.isQuickPlay as boolean
                }));
                dispatch(setRoomLoading(false));
              }
              break;
              
            case 'room_players':
              if ('players' in messageData) {
                console.log('Joueurs de la salle re√ßus:', messageData.players);
                dispatch(updateRoomPlayers(messageData.players as WaitingPlayer[]));
              }
              break;
              
            case 'player_ready':
              if ('playerId' in messageData && 'isReady' in messageData) {
                console.log('Statut pr√™t du joueur:', messageData.playerId, messageData.isReady);
                dispatch(updatePlayerReady({
                  playerId: messageData.playerId as string,
                  isReady: messageData.isReady as boolean
                }));
              }
              break;
              
            case 'salon_created':
            case 'created':
              if ('roomId' in messageData) {
                console.log('Salle cr√©√©e avec succ√®s:', messageData.roomId);
                if (onRoomCreated && typeof messageData.roomId === 'number') {
                  onRoomCreated(messageData.roomId);
                }
              } else {
                console.log('Salle cr√©√©e avec succ√®s');
                dispatch(setRoomsLoading(true));
                sendWebSocketMessage('get_salons');
              }
              break;
              
            case 'game_start':
              console.log('Le jeu commence !');
              break;
              
            case 'join_room_success':
            case 'room_joined':
            case 'connected':
              console.log('Salle rejoint avec succ√®s');
              dispatch(setRoomLoading(false));
              break;
              
            default:
              console.log('Message pars√© non g√©r√©:', messageData.type, messageData);
          }
        } else {
          console.log('Message sans type, traitement direct:', parsedMessage);
          
          // D√©tecter si c'est un message de cr√©ation renvoy√© par le serveur
          if (typeof parsedMessage === 'string' && parsedMessage.startsWith('create:')) {
            console.log('üéâ Message de cr√©ation confirm√© par le serveur:', parsedMessage);
            try {
              const createData = JSON.parse(parsedMessage.substring(7));
              console.log('Donn√©es de cr√©ation:', createData);
              
              dispatch(setRoomsLoading(true));
              sendWebSocketMessage('get_salons');
              
              if (onRoomCreated) {
                onRoomCreated(Date.now());
              }
            } catch (error) {
              console.error('Erreur lors du parsing des donn√©es de cr√©ation:', error);
            }
            return;
          }
          
          // D√©tecter les messages de succ√®s de connexion (format: "Vous avez rejoint le salon...")
          if (typeof parsedMessage === 'string' && parsedMessage.includes('rejoint le salon')) {
            console.log('üéâ Message de connexion r√©ussie:', parsedMessage);
            dispatch(setRoomLoading(false));
            
            // Demander les donn√©es de la salle apr√®s avoir rejoint
            setTimeout(() => {
              if (roomId) {
                console.log('Demande des donn√©es de la salle apr√®s connexion...');
                sendWebSocketMessage(`get_salon_info-${roomId}`);
                sendWebSocketMessage(`get_players-${roomId}`);
              }
            }, 500);
            return;
          }
          
          // D√©tecter les donn√©es de quiz
          if (parsedMessage && typeof parsedMessage === 'object') {
            const dataObj = parsedMessage as Record<string, unknown>;
            
            if ('quizz' in dataObj || 'quiz' in dataObj) {
              console.log('Donn√©es de quiz d√©tect√©es:', dataObj);
              const quizz = dataObj.quizz || dataObj.quiz;
              if (quizz && typeof quizz === 'object') {
                dispatch(updateRoomInfo({
                  quizz: quizz as Quizz,
                  isQuickPlay: dataObj.isQuickPlay as boolean || false
                }));
                dispatch(setRoomLoading(false));
              }
            }
            
            // D√©tecter les donn√©es de joueurs
            if ('players' in dataObj && Array.isArray(dataObj.players)) {
              console.log('Donn√©es de joueurs d√©tect√©es:', dataObj.players);
              dispatch(updateRoomPlayers(dataObj.players as WaitingPlayer[]));
            }
          }
        }
      } catch (error) {
        console.log('Erreur lors du parsing du message:', error);
      }
      return;
    }
    
    // G√©rer les messages avec format type direct (fallback)
    if (data && typeof data === 'object' && 'type' in data) {
      const messageData = data as { type: string; [key: string]: unknown };
      
      switch (messageData.type) {
        case 'salons_init':
          if ('salons' in messageData) {
            console.log('Donn√©es des salons re√ßues:', messageData.salons);
            dispatch(setRooms(messageData.salons as Room[]));
          }
          break;
          
        case 'join_room':
          console.log('Confirmation de rejoindre la salle');
          dispatch(setRoomLoading(false));
          break;
          
        case 'get_room_info':
        case 'get_room_players':
          console.log('Confirmation de demande de donn√©es:', messageData.type);
          break;
          
        case 'room_info':
          if ('quizz' in messageData && 'isQuickPlay' in messageData) {
            console.log('Informations de salle re√ßues:', messageData.quizz);
            dispatch(updateRoomInfo({
              quizz: messageData.quizz as Quizz,
              isQuickPlay: messageData.isQuickPlay as boolean
            }));
            dispatch(setRoomLoading(false));
          }
          break;
          
        case 'room_players':
          if ('players' in messageData) {
            console.log('Joueurs de la salle re√ßus:', messageData.players);
            dispatch(updateRoomPlayers(messageData.players as WaitingPlayer[]));
          }
          break;
          
        case 'player_ready':
          if ('playerId' in messageData && 'isReady' in messageData) {
            console.log('Statut pr√™t du joueur:', messageData.playerId, messageData.isReady);
            dispatch(updatePlayerReady({
              playerId: messageData.playerId as string,
              isReady: messageData.isReady as boolean
            }));
          }
          break;
          
        case 'salon_created':
        case 'created':
          if ('roomId' in messageData) {
            console.log('Salle cr√©√©e avec succ√®s:', messageData.roomId);
            if (onRoomCreated && typeof messageData.roomId === 'number') {
              onRoomCreated(messageData.roomId);
            }
          } else {
            console.log('Salle cr√©√©e avec succ√®s');
            dispatch(setRoomsLoading(true));
            sendWebSocketMessage('get_salons');
          }
          break;
          
        case 'game_start':
          console.log('Le jeu commence !');
          break;
          
        case 'join_room_success':
        case 'room_joined':
        case 'connected':
          console.log('Salle rejoint avec succ√®s');
          dispatch(setRoomLoading(false));
          break;
          
        default:
          console.log('Message non g√©r√©:', messageData.type, messageData);
      }
    } else {
      console.log('Message non structur√© re√ßu:', data);
      
      // Essayer de d√©tecter les donn√©es de salle dans n'importe quel format
      if (data && typeof data === 'object') {
        const dataObj = data as Record<string, unknown>;
        
        // D√©tecter les donn√©es de quiz
        if ('quizz' in dataObj || 'quiz' in dataObj) {
          console.log('Donn√©es de quiz d√©tect√©es:', dataObj);
          const quizz = dataObj.quizz || dataObj.quiz;
          if (quizz && typeof quizz === 'object') {
            dispatch(updateRoomInfo({
              quizz: quizz as Quizz,
              isQuickPlay: dataObj.isQuickPlay as boolean || false
            }));
            dispatch(setRoomLoading(false));
          }
        }
        
        // D√©tecter les donn√©es de joueurs
        if ('players' in dataObj && Array.isArray(dataObj.players)) {
          console.log('Donn√©es de joueurs d√©tect√©es:', dataObj.players);
          dispatch(updateRoomPlayers(dataObj.players as WaitingPlayer[]));
        }
      }
    }
  }, [dispatch, onRoomCreated]);

  // Gestionnaire d'erreur
  const handleError = useCallback((error: Event) => {
    console.error("Erreur WebSocket:", error);
    dispatch(setError('Erreur de connexion WebSocket'));
  }, [dispatch]);

  // Gestionnaire de connexion
  const handleOpen = useCallback(() => {
    console.log("WebSocket connect√©");
    dispatch(setConnected(true));
  }, [dispatch]);

  // Gestionnaire de d√©connexion
  const handleClose = useCallback((event: CloseEvent) => {
    console.log("WebSocket ferm√©:", event.code);
    dispatch(setConnected(false));
  }, [dispatch]);

  // Hook WebSocket
  const { sendWebSocketMessage } = useWebSocket({
    id: roomId ? `room-${roomId}` : 'global',
    callbacks: {
      onMessage: handleMessage,
      onError: handleError,
      onOpen: handleOpen,
      onClose: handleClose
    }
  });

  // Effet pour rejoindre une salle
  useEffect(() => {
    if (roomId && isConnected) {
      console.log(`Rejoindre la salle ${roomId}...`);
      dispatch(setRoomLoading(true));
      dispatch(resetRoom());
      
      // Petit d√©lai pour s'assurer que la connexion est stable
      const timeout = setTimeout(() => {
        // Utiliser le format attendu par le backend: connect-{salonId}
        sendWebSocketMessage(`connect-${roomId}`);
      }, 500);

      return () => clearTimeout(timeout);
    }
  }, [roomId, isConnected, sendWebSocketMessage, dispatch]);

  // Effet pour demander les donn√©es de la salle apr√®s avoir rejoint
  useEffect(() => {
    if (roomId && isConnected && !roomLoading && !currentRoom) {
      console.log('Demande des donn√©es de la salle apr√®s avoir rejoint...');
      
      let retryCount = 0;
      const maxRetries = 3;
      
      const requestRoomData = () => {
        console.log(`Tentative ${retryCount + 1}/${maxRetries} de r√©cup√©ration des donn√©es de la salle...`);
        // Demander les informations de la salle avec le bon format
        sendWebSocketMessage(`get_salon_info-${roomId}`);
        sendWebSocketMessage(`get_players-${roomId}`);
        
        retryCount++;
        
        if (retryCount < maxRetries) {
          // Retry apr√®s 2 secondes si pas de donn√©es
          setTimeout(() => {
            if (!currentRoom) {
              requestRoomData();
            }
          }, 2000);
        } else {
          console.warn('Impossible de r√©cup√©rer les donn√©es de la salle apr√®s', maxRetries, 'tentatives');
          dispatch(setError('Impossible de r√©cup√©rer les donn√©es de la salle'));
        }
      };
      
      // Premi√®re tentative apr√®s 1 seconde
      const timeout = setTimeout(requestRoomData, 1000);

      return () => clearTimeout(timeout);
    }
  }, [roomId, isConnected, roomLoading, currentRoom, sendWebSocketMessage, dispatch]);

  // Actions
  const createRoom = useCallback((roomData: { label: string; difficulte: number; j_max: number }) => {
    // Utiliser le format attendu par le backend: create:{"label":"Mon Salon","difficulte":2,"j_max":4}
    // √âviter le double JSON.stringify qui cause l'√©chappement
    const message = `create:${JSON.stringify(roomData)}`;
    console.log('üì§ Envoi du message de cr√©ation:', message);
    sendWebSocketMessage(message);
  }, [sendWebSocketMessage]);

  const createQuickRoom = useCallback(() => {
    // Utiliser le format attendu par le backend pour un salon rapide
    sendWebSocketMessage('rapide');
  }, [sendWebSocketMessage]);

  const setPlayerReady = useCallback((isReady: boolean) => {
    if (roomId) {
      // Utiliser le format attendu par le backend pour le statut pr√™t
      sendWebSocketMessage(`player_ready-${roomId}-${isReady}`);
    }
  }, [roomId, sendWebSocketMessage]);

  const refreshRooms = useCallback(() => {
    dispatch(setRoomsLoading(true));
    sendWebSocketMessage('get_salons');
  }, [sendWebSocketMessage, dispatch]);

  return {
    // √âtat
    isConnected,
    hasReceivedData,
    rooms,
    roomsLoading,
    currentRoom,
    roomLoading,
    error,
    
    // Actions
    sendWebSocketMessage,
    createRoom,
    createQuickRoom,
    setPlayerReady,
    refreshRooms
  };
}; 